So I'll talk briefly about design here, although most of it is really self-apparent in the implementation. The main thing I'll mention is that what's important is being able to track backwards and have a history of minimums; my original idea here was to use a stack where I had access to the internal nodes, and add a prevMin* pointer to each node, such that any node that had ever been a minimum would point to the node that was a minimum before it. This is slightly more convoluted and marginally more efficient than the two-stack design I used, but two stacks is much simpler to implement. Also I wrote the code for integers, but it would be easy to expand into something templated.

Proofs:
I don't necessarily know that much needs to be proved about push(), pop() and top(). They're all very easily apparent as O(1) because there's just no looping or iteration involved. They're correct because all they really do is call the underlying stack methods.

isEmpty is O(1) because it only performs a single comparison. That it is correct is readily self apparent based on the fact that it checks a number that starts at 0, goes up by 1 per insert (push) and down by one per removal (pop) so we know that if the size is 0 the stack is in fact empty.

getMin is the important one here. It returns the saved minimum value, so the important part is proving that the saved value is always correct. We can easily see that it will always be correct based only on inserts (pushes), because every element is compared against the current minimum and the current minimum is updated only if the inserted element is less. Obviously if an element is less than the current min Z and Z was less than the previous min X, we can see that the current element is <Z<X by transitivity.

The tricky part is preserving our min when an element is popped. When a non-minimum element is popped, nothing changes, so it's not problematic. If a minimum element is popped, we need to be able to get the next smallest item in the stack. Before going any further, it's important to note that an item below the minimum will either have been minimum at some point or be larger than every element that has previously been a minimum above it (because if this were not true, it would have been inserted at some point when it was less than a minimum and the minimum wasn't updated, which is a contradiction with our push method). Additionally, there will always be a first minimum that is at the bottom of the stack.

Based on the above, we know that we can safely roll back to the previous minimum and have a valid minimum for the stack, because pop() calls can only remove the top element, so we know we'll work back down our stack in order. Therefore, as long as we can get the previous minimum before a given minimum, we can always find a valid minimum when one is popped. This is done by maintaining a stack of minimums.
